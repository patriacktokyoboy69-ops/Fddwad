
-- ================== SERVICES ==================
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Player = LocalPlayer
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Remotes = ReplicatedStorage:WaitForChild("Remotes")
local RunService = game:GetService("RunService")
local VIM = game:GetService("VirtualInputManager")

-- ================== GLOBAL FLAG ==================
_G.TUTORIAL_SCRIPT_RUNNING = true

-- ================== SAFE REMOTE ==================
local function safeFire(remote, ...)
	local args = { ... }
	local ok, err = pcall(function()
		remote:FireServer(unpack(args))
	end)
	if ok then
		print("âœ… Fired:", remote.Name)
	else
		warn("âŒ Fire failed:", remote.Name, err)
	end
end

local function safeInvoke(remote, ...)
	local args = { ... }
	local ok, result = pcall(function()
		return remote:InvokeServer(unpack(args))
	end)
	if ok then
		print("âœ… Invoke:", remote.Name, result)
	else
		warn("âŒ Invoke failed:", remote.Name, result)
	end
	return result
end

-- ================================================================
-- ğŸ‰ à¸£à¸°à¸šà¸šà¸¡à¸±à¸‡à¸à¸£ (Dragon System)
-- ================================================================
local function setupDragonSystem()
	print("ğŸ‰ à¸•à¸±à¹‰à¸‡à¸„à¹ˆà¸²à¸¡à¸±à¸‡à¸à¸£...")
	task.spawn(function()
		pcall(function()
			-- à¸£à¸­ Character
			local char = Player.Character
			if not char then
				print("â³ à¸£à¸­ Character...")
				char = Player.CharacterAdded:Wait()
				task.wait(2)
			end

			local remotes = ReplicatedStorage:FindFirstChild("Remotes")
			if not remotes then
				warn("âŒ à¹„à¸¡à¹ˆà¸à¸š Remotes")
				return
			end

			-- à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™à¹€à¸£à¸µà¸¢à¸à¸¡à¸±à¸‡à¸à¸£
			local function equipDragon()
				local success = pcall(function()
					print("ğŸ“ à¹€à¸£à¸µà¸¢à¸à¸¡à¸±à¸‡à¸à¸£...")
					local args = {"1"}
					local equipRemote = remotes:FindFirstChild("EquipDragonRemote")
					if equipRemote then
						equipRemote:InvokeServer(unpack(args))
						print("âœ… à¹€à¸£à¸µà¸¢à¸à¸¡à¸±à¸‡à¸à¸£à¸ªà¸³à¹€à¸£à¹‡à¸ˆ")
						task.wait(1)
						return true
					else
						warn("âŒ à¹„à¸¡à¹ˆà¸à¸š EquipDragonRemote")
						return false
					end
				end)
				return success
			end

			-- à¸«à¸² Dragon folder
			local dragonFolder = nil
			pcall(function()
				dragonFolder = workspace:WaitForChild("Characters", 10)
					:WaitForChild(Player.Name, 10)
					:WaitForChild("Dragons", 10)
			end)

			if not dragonFolder then
				warn("âŒ à¹„à¸¡à¹ˆà¸à¸š Dragons folder")
				return
			end

			print("âœ… à¸à¸š Dragons folder")

			local function getAutoDragon()
				local dragons = dragonFolder:GetChildren()
				if #dragons > 0 then
					return dragons[1]
				end
				return nil
			end

			local function reviveDragon(dragonModel)
				pcall(function()
					local dragonName = dragonModel.Name
					local deadFlag = dragonModel:FindFirstChild("Data") and dragonModel.Data:FindFirstChild("Dead")
					
					if deadFlag and deadFlag.Value == true then
						print("ğŸ’€ à¸Ÿà¸·à¹‰à¸™à¸¡à¸±à¸‡à¸à¸£:", dragonName)
						local args = {
							dragonName,
							"DragonRevivalHeart"
						}
						local reviveRemote = remotes:FindFirstChild("ReviveDragonRemote")
						if reviveRemote then
							reviveRemote:InvokeServer(unpack(args))
							task.wait(1)
						end
					end
				end)
			end

			local function isMountedOnDragon()
				local result = false
				pcall(function()
					local humanoid = char:FindFirstChildOfClass("Humanoid")
					if humanoid and humanoid.SeatPart then
						local seat = humanoid.SeatPart
						local dragonModel = seat:FindFirstAncestorWhichIsA("Model")
						if dragonModel and dragonModel:IsDescendantOf(dragonFolder) then
							result = true
						end
					end
				end)
				return result
			end

			local function ensureMountedDragon()
				pcall(function()
					if isMountedOnDragon() then
						return
					end

					print("âš ï¸ à¹„à¸¡à¹ˆà¹„à¸”à¹‰à¸‚à¸µà¹ˆà¸¡à¸±à¸‡à¸à¸£!")

					local dragonModel = getAutoDragon()
					
					if not dragonModel then
						print("ğŸ” à¹„à¸¡à¹ˆà¸à¸šà¸¡à¸±à¸‡à¸à¸£ - à¹€à¸£à¸µà¸¢à¸à¸¡à¸±à¸‡à¸à¸£à¸­à¸­à¸à¸¡à¸²")
						equipDragon()
						task.wait(2)
						dragonModel = getAutoDragon()
						
						if not dragonModel then
							warn("âŒ à¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¸à¸šà¸¡à¸±à¸‡à¸à¸£à¸«à¸¥à¸±à¸‡à¹€à¸£à¸µà¸¢à¸")
							return
						end
					end

					local targetName = dragonModel.Name
					print("ğŸ‰ à¸à¸šà¸¡à¸±à¸‡à¸à¸£:", targetName)

					reviveDragon(dragonModel)
					task.wait(0.5)

					local seat = dragonModel:FindFirstChildWhichIsA("Seat", true)
					local humanoid = char:FindFirstChildOfClass("Humanoid")
					
					if seat and humanoid then
						print("ğŸª¶ à¸à¸³à¸¥à¸±à¸‡à¸‚à¸µà¹ˆà¸¡à¸±à¸‡à¸à¸£...")
						seat:Sit(humanoid)
						task.wait(1)

						pcall(function()
							local flyBtn = Player.PlayerGui
								:WaitForChild("HUDGui", 5)
								.BottomFrame.CurrentDragonFrame
								.DragonControlsFrame.Other:FindFirstChild("Fly")
							
							if flyBtn and flyBtn:FindFirstChild("MouseButton1Down") then
								firesignal(flyBtn.MouseButton1Down)
								print("ğŸ›« à¸šà¸´à¸™!")
							end
						end)
					else
						warn("âŒ à¹„à¸¡à¹ˆà¸à¸šà¸—à¸µà¹ˆà¸™à¸±à¹ˆà¸‡à¸«à¸£à¸·à¸­ Humanoid")
					end
				end)
			end

			-- à¹€à¸Šà¹‡à¸„à¸‹à¹‰à¸³à¸—à¸¸à¸ 3 à¸§à¸´à¸™à¸²à¸—à¸µ
			task.spawn(function()
				while _G.TUTORIAL_SCRIPT_RUNNING do
					task.wait(3)
					pcall(ensureMountedDragon)
				end
			end)

			Player.CharacterAdded:Connect(function(newChar)
				task.wait(3)
				char = newChar
				pcall(ensureMountedDragon)
			end)

			print("âœ… à¸£à¸°à¸šà¸šà¸¡à¸±à¸‡à¸à¸£à¸à¸£à¹‰à¸­à¸¡")
			
			task.wait(2)
			ensureMountedDragon()
		end)
	end)
end

-- ================================================================
-- âŒ¨ï¸ à¸£à¸°à¸šà¸šà¸à¸” Q (Auto Fly Control)
-- ================================================================
local function setupAutoFlyControl()
	print("âŒ¨ï¸ à¸•à¸±à¹‰à¸‡à¸„à¹ˆà¸²à¸›à¸¸à¹ˆà¸¡ Q...")
	
	task.spawn(function()
		pcall(function()
			task.wait(2)
			pcall(function()
				local settings = Player:WaitForChild("Data", 10):WaitForChild("Settings", 10)
				local flyControl = settings:FindFirstChild("FlyControlUseSpace")
				if flyControl then
					flyControl.Value = false
					print("âœ… FlyControlUseSpace = false")
				end
			end)
			
			local function pressQ()
				pcall(function()
					VIM:SendKeyEvent(true, Enum.KeyCode.Q, false, game)
					task.wait(0.05)
					VIM:SendKeyEvent(false, Enum.KeyCode.Q, false, game)
				end)
			end
			
			local function getDragonFlying()
				local result = false
				pcall(function()
					local char = Player.Character
					if not char then return end
					
					local dragons = char:FindFirstChild("Dragons")
					if not dragons then return end
					
					for _, dragon in ipairs(dragons:GetChildren()) do
						if dragon:IsA("Model") then
							local data = dragon:FindFirstChild("Data")
							if data then
								local flying = data:FindFirstChild("Flying")
								if flying then
									result = flying.Value
									return
								end
							end
						end
					end
				end)
				return result
			end
			
			task.wait(3)
			while _G.TUTORIAL_SCRIPT_RUNNING do
				task.wait(0.5)
				
				local isFlying = getDragonFlying()
				
				if not isFlying then
					print("âš ï¸ à¸¡à¸±à¸‡à¸à¸£à¹„à¸¡à¹ˆà¸šà¸´à¸™ â†’ Q")
					pressQ()
					task.wait(0.1)
					pressQ()
				end
			end
		end)
	end)
	
	print("âœ… à¸£à¸°à¸šà¸š Q à¸à¸£à¹‰à¸­à¸¡")
end

-- ================== LOBBY QUEST FUNCTIONS ==================

local currentWorldName = "Lobby"

local function getMissionValue(missionName)
	local ok, result = pcall(function()
		return Player.Data.WorldMissions[currentWorldName].Missions[missionName].Progress.Value
	end)
	return ok and result or 0
end

local function isMissionDone(missionName, required)
	return getMissionValue(missionName) >= required
end

local function isLobbyEggDone()
	return isMissionDone("EggQuest", 1)
end

local function isRingDone()
	return isMissionDone("RidingRing", 10)
end

-- ğŸ¥š à¹€à¸„à¸§à¸ªà¹„à¸‚à¹ˆ Lobby
local function findAnyLobbyEgg()
	local folder = workspace:FindFirstChild("Interactions")
		and workspace.Interactions:FindFirstChild("Nodes")
		and workspace.Interactions.Nodes:FindFirstChild("Eggs")
		and workspace.Interactions.Nodes.Eggs:FindFirstChild("ActiveNodes")

	if not folder then
		warn("âŒ à¹„à¸¡à¹ˆà¸à¸š ActiveNodes à¸‚à¸­à¸‡à¹„à¸‚à¹ˆ")
		return nil
	end

	for _, node in ipairs(folder:GetChildren()) do
		local egg = node:FindFirstChild("EggModel")
		if egg then
			local harvested = node:FindFirstChild("Harvested") or egg:FindFirstChild("Harvested")
			if not harvested or harvested.Value == false then
				return egg, node
			end
		end
	end

	return nil
end

local function tpTo(pos)
	local char = LocalPlayer.Character
	if not char or not char.PrimaryPart then return end

	for _, p in ipairs(char:GetDescendants()) do
		if p:IsA("BasePart") then
			p.CanCollide = false
		end
	end

	char:PivotTo(CFrame.new(pos + Vector3.new(0, 3, 0)))
	task.wait(0.2)

	for _, p in ipairs(char:GetDescendants()) do
		if p:IsA("BasePart") then
			p.CanCollide = true
		end
	end
end

local function startLobbyEggQuest()
	print("ğŸ¥š à¹€à¸£à¸´à¹ˆà¸¡à¹€à¸„à¸§à¸ªà¹„à¸‚à¹ˆ Lobby")

	local egg, node = findAnyLobbyEgg()

	if not egg then
		warn("âŒ à¹„à¸¡à¹ˆà¸à¸šà¹„à¸‚à¹ˆ Lobby")
		return
	end

	print("âœ… à¹€à¸ˆà¸­à¹„à¸‚à¹ˆ:", egg.Name)

	if egg:IsA("Model") then
		if egg.PrimaryPart then
			tpTo(egg.PrimaryPart.Position)
		else
			local part = egg:FindFirstChildWhichIsA("BasePart")
			if part then tpTo(part.Position) end
		end
	elseif egg:IsA("BasePart") then
		tpTo(egg.Position)
	end

	task.wait(0.4)

	local harvested = node:FindFirstChild("Harvested") or egg:FindFirstChild("Harvested")

	if harvested then
		harvested.Value = true
		print("âœ¨ à¹€à¸à¹‡à¸šà¹„à¸‚à¹ˆà¸ªà¸³à¹€à¸£à¹‡à¸ˆ!")
	end

	task.wait(0.5)
end

-- ğŸŒ€ à¹€à¸„à¸§à¸ªà¸§à¸‡à¹à¸«à¸§à¸™
local TARGET_PROGRESS = 10

local function isRidingMissionCompleted()
	return getMissionValue("RidingRing") >= TARGET_PROGRESS
end

local function getPlayerRoot()
	local char = LocalPlayer.Character
	if not char then return nil end

	local dragons = char:FindFirstChild("Dragons")
	if dragons then
		for _, d in ipairs(dragons:GetChildren()) do
			if d:IsA("Model") and d:FindFirstChild("HumanoidRootPart") then
				return d.HumanoidRootPart
			end
		end
	end

	return char:FindFirstChild("HumanoidRootPart")
end

local function getFlyingFolder()
	local root = workspace:FindFirstChild("Interactions")
	if not root then return nil end
	root = root:FindFirstChild("RidingRings")
	if not root then return nil end
	return root:FindFirstChild("Flying")
end

local function getDynamicRing()
	local folder = getFlyingFolder()
	if not folder then return nil end

	local currentProgress = getMissionValue("RidingRing")
	local targetRingNumber = currentProgress + 1

	for _, item in ipairs(folder:GetChildren()) do
		local part = nil

		if item:IsA("BasePart") then
			part = item
		elseif item:IsA("Model") then
			part = item:FindFirstChildWhichIsA("BasePart")
		end

		if part then
			local num = tonumber(part.Name) or tonumber(item.Name)
			if num == targetRingNumber then
				print("ğŸ¯ à¹€à¸ˆà¸­à¸§à¸‡à¸—à¸µà¹ˆ " .. targetRingNumber)
				return part
			end
		end
	end

	local best = nil
	local bestIndex = math.huge

	for _, item in ipairs(folder:GetChildren()) do
		local part = nil

		if item:IsA("BasePart") then
			part = item
		elseif item:IsA("Model") then
			part = item:FindFirstChildWhichIsA("BasePart")
		end

		if part then
			local num = tonumber(part.Name) or tonumber(item.Name) or 999999
			if num < bestIndex then
				bestIndex = num
				best = part
			end
		end
	end

	return best
end

local function flyToRing(hrp, ringPart, speed, maxTime)
	if not hrp or not ringPart then return end
	speed = speed or 10
	maxTime = maxTime or 8

	local startTime = tick()
	local lastDist = math.huge

	while true do
		if not hrp.Parent then return end
		if not ringPart.Parent then return end
		if isRidingMissionCompleted() then return end

		local target = ringPart.Position + Vector3.new(0, 3, 0)
		local pos = hrp.Position
		local dist = (target - pos).Magnitude

		if dist <= 3 then
			print("âœ… à¸œà¹ˆà¸²à¸™à¸§à¸‡!")
			return
		end

		if tick() - startTime > maxTime then
			warn("â±ï¸ flyToRing timeout")
			return
		end

		if dist > lastDist + 2 then
			return
		end
		lastDist = dist

		hrp.CFrame = CFrame.new(pos, target)
		hrp.CFrame = hrp.CFrame + (target - pos).Unit * speed * 0.6

		task.wait(0.03)
	end
end

local noclipEnabled = false
local noclipConnection = nil

local function enableNoclip()
	if noclipEnabled then return end
	noclipEnabled = true

	noclipConnection = RunService.Heartbeat:Connect(function()
		if not noclipEnabled then return end
		local char = LocalPlayer.Character
		if char then
			for _, part in ipairs(char:GetDescendants()) do
				if part:IsA("BasePart") then
					part.CanCollide = false
				end
			end
		end
	end)

	print("ğŸŸ£ Noclip â†’ ON")
end

local function disableNoclip()
	if not noclipEnabled then return end
	noclipEnabled = false

	if noclipConnection then
		noclipConnection:Disconnect()
		noclipConnection = nil
	end

	local char = LocalPlayer.Character
	if char then
		for _, p in ipairs(char:GetDescendants()) do
			if p:IsA("BasePart") then
				p.CanCollide = true
			end
		end
	end

	print("âšª Noclip â†’ OFF")
end

local function antiStuck()
	task.spawn(function()
		while not isRidingMissionCompleted() do
			task.wait(math.random(2, 8))
			VIM:SendKeyEvent(true, Enum.KeyCode.D, false, game)
			task.wait(0.1)
			VIM:SendKeyEvent(false, Enum.KeyCode.D, false, game)
		end
	end)
end

local function startRidingRingFly()
	print("ğŸŒ€ à¹€à¸£à¸´à¹ˆà¸¡à¹€à¸„à¸§à¸ªà¸§à¸‡à¹à¸«à¸§à¸™")

	enableNoclip()
	antiStuck()

	local lastProgress = getMissionValue("RidingRing")
	local stuckTime = tick()

	while not isRidingMissionCompleted() do
		local hrp = getPlayerRoot()
		if not hrp then
			warn("âš ï¸ HRP à¹„à¸¡à¹ˆà¸à¸š")
			task.wait(0.5)
			continue
		end

		local ring = getDynamicRing()
		if not ring then
			warn("âŒ à¹„à¸¡à¹ˆà¸à¸šà¸§à¸‡à¹à¸«à¸§à¸™")
			task.wait(0.5)
			continue
		end

		local currentProgress = getMissionValue("RidingRing")
		print(("â¡ï¸ Ring: %s | %d/%d"):format(ring.Name, currentProgress, TARGET_PROGRESS))

		flyToRing(hrp, ring, 10, 8)
		
		local newProgress = getMissionValue("RidingRing")
		if newProgress > lastProgress then
			lastProgress = newProgress
			stuckTime = tick()
			print("âœ… à¸œà¹ˆà¸²à¸™à¸§à¸‡à¹à¸¥à¹‰à¸§! (" .. newProgress .. "/10)")
		else
			if tick() - stuckTime > 10 then
				warn("âš ï¸ à¹„à¸¡à¹ˆà¸œà¹ˆà¸²à¸™à¸§à¸‡à¸™à¸²à¸™à¹€à¸à¸´à¸™à¹„à¸› â†’ à¸¥à¸­à¸‡à¹ƒà¸«à¸¡à¹ˆ")
				stuckTime = tick()
			end
		end

		task.wait(0.2)
	end

	print("ğŸ‰ à¸§à¸‡à¹à¸«à¸§à¸™à¹€à¸ªà¸£à¹‡à¸ˆà¸ªà¸´à¹‰à¸™!")
	disableNoclip()
end

local function completeLobbyQuests()
	print("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
	print("ğŸ›ï¸ à¹€à¸£à¸´à¹ˆà¸¡à¸—à¸³à¹€à¸„à¸§à¸ª LOBBY")
	print("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")

	task.wait(3)

	if not isLobbyEggDone() then
		print("ğŸ¥š à¸—à¸³à¹€à¸„à¸§à¸ªà¹„à¸‚à¹ˆ...")
		startLobbyEggQuest()

		local timeout = tick() + 60
		while not isLobbyEggDone() and tick() < timeout do
			task.wait(2)
		end

		if isLobbyEggDone() then
			print("âœ… à¹€à¸„à¸§à¸ªà¹„à¸‚à¹ˆà¹€à¸ªà¸£à¹‡à¸ˆ!")
		else
			warn("âŒ Timeout à¹€à¸„à¸§à¸ªà¹„à¸‚à¹ˆ")
		end
	else
		print("âœ… à¹€à¸„à¸§à¸ªà¹„à¸‚à¹ˆà¹€à¸ªà¸£à¹‡à¸ˆà¹à¸¥à¹‰à¸§ (à¸‚à¹‰à¸²à¸¡)")
	end

	task.wait(2)

	if not isRingDone() then
		print("ğŸŒ€ à¸—à¸³à¹€à¸„à¸§à¸ªà¸§à¸‡à¹à¸«à¸§à¸™...")
		startRidingRingFly()

		if isRingDone() then
			print("âœ… à¹€à¸„à¸§à¸ªà¸§à¸‡à¹à¸«à¸§à¸™à¹€à¸ªà¸£à¹‡à¸ˆ!")
		else
			warn("âŒ à¹€à¸„à¸§à¸ªà¸§à¸‡à¹à¸«à¸§à¸™à¹„à¸¡à¹ˆà¸ªà¸³à¹€à¸£à¹‡à¸ˆ")
		end
	else
		print("âœ… à¹€à¸„à¸§à¸ªà¸§à¸‡à¹à¸«à¸§à¸™à¹€à¸ªà¸£à¹‡à¸ˆà¹à¸¥à¹‰à¸§ (à¸‚à¹‰à¸²à¸¡)")
	end

	print("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
	
	if isLobbyEggDone() and isRingDone() then
		print("ğŸ‰ à¹€à¸„à¸§à¸ª LOBBY à¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”à¹€à¸ªà¸£à¹‡à¸ˆà¸ªà¸´à¹‰à¸™!")
		return true
	else
		warn("âš ï¸ à¹€à¸„à¸§à¸ª LOBBY à¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¹€à¸ªà¸£à¹‡à¸ˆà¸„à¸£à¸š")
		return false
	end
end

-- ================== NEST CHECK + FIXSCRIPT ==================
local function waitForNestOrFix(timeout)
	timeout = timeout or 5
	local start = tick()

	print("ğŸ” à¸à¸³à¸¥à¸±à¸‡à¸•à¸£à¸§à¸ˆà¸«à¸² workspace.Environment.Nest...")

	while tick() - start < timeout do
		local env = workspace:FindFirstChild("Environment")
		if env and env:FindFirstChild("Nest") then
			print("ğŸªº à¸à¸š workspace.Environment.Nest à¹à¸¥à¹‰à¸§ âœ…")
			return env.Nest
		end
		task.wait(0.5)
	end

	warn("âŒ à¹„à¸¡à¹ˆà¸à¸š Nest à¸ à¸²à¸¢à¹ƒà¸™ " .. timeout .. " à¸§à¸´à¸™à¸²à¸—à¸µ")
	
	print("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
	print("ğŸ“‹ à¹€à¸Šà¹‡à¸„à¹€à¸„à¸§à¸ª Lobby à¸à¹ˆà¸­à¸™à¸£à¸±à¸™ Fixscript")
	print("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
	
	local lobbyQuestsComplete = false
	
	if game.PlaceId == 3475397644 then
		print("ğŸ›ï¸ à¸­à¸¢à¸¹à¹ˆà¹ƒà¸™ Lobby â†’ à¹€à¸£à¸´à¹ˆà¸¡à¹€à¸Šà¹‡à¸„à¹€à¸„à¸§à¸ª")
		
		local eggDone = isLobbyEggDone()
		local ringDone = isRingDone()
		
		print("ğŸ“Š à¸ªà¸–à¸²à¸™à¸°à¹€à¸„à¸§à¸ª:")
		print("   ğŸ¥š Egg: " .. (eggDone and "âœ… à¹€à¸ªà¸£à¹‡à¸ˆ" or "âŒ à¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¹€à¸ªà¸£à¹‡à¸ˆ"))
		print("   ğŸŒ€ Ring: " .. (ringDone and "âœ… à¹€à¸ªà¸£à¹‡à¸ˆ" or "âŒ à¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¹€à¸ªà¸£à¹‡à¸ˆ"))
		
		if eggDone and ringDone then
			print("âœ… à¹€à¸„à¸§à¸ª Lobby à¸„à¸£à¸šà¹à¸¥à¹‰à¸§ â†’ à¸‚à¹‰à¸²à¸¡à¹„à¸›à¸£à¸±à¸™ Fixscript")
			lobbyQuestsComplete = true
		else
			print("âš ï¸ à¹€à¸„à¸§à¸ª Lobby à¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¸„à¸£à¸š â†’ à¸—à¸³à¹ƒà¸«à¹‰à¹€à¸ªà¸£à¹‡à¸ˆà¸à¹ˆà¸­à¸™")
			lobbyQuestsComplete = completeLobbyQuests()
		end
	else
		warn("âš ï¸ à¹„à¸¡à¹ˆà¹„à¸”à¹‰à¸­à¸¢à¸¹à¹ˆà¹ƒà¸™ Lobby â†’ à¸‚à¹‰à¸²à¸¡à¸à¸²à¸£à¹€à¸Šà¹‡à¸„à¹€à¸„à¸§à¸ª")
		lobbyQuestsComplete = true
	end
	
	print("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
	
	if lobbyQuestsComplete then
		warn("ğŸ”§ à¸£à¸±à¸™ Fixscript...")
		
		local fixSuccess = pcall(function()
			loadstring(game:HttpGet(
				"https://raw.githubusercontent.com/patriacktokyoboy69-ops/sfafwafwaf/refs/heads/main/awdwad"
			))()
		end)
		
		if fixSuccess then
			print("âœ… à¸£à¸±à¸™ Fixscript à¸ªà¸³à¹€à¸£à¹‡à¸ˆ")
			task.wait(5)
			
			local env = workspace:FindFirstChild("Environment")
			if env and env:FindFirstChild("Nest") then
				print("ğŸªº à¸à¸š Nest à¸«à¸¥à¸±à¸‡à¸£à¸±à¸™ Fixscript âœ…")
				return env.Nest
			end
		else
			warn("âŒ à¸£à¸±à¸™ Fixscript à¸¥à¹‰à¸¡à¹€à¸«à¸¥à¸§")
		end
	else
		warn("âŒ à¹€à¸„à¸§à¸ª Lobby à¹„à¸¡à¹ˆà¸ªà¸³à¹€à¸£à¹‡à¸ˆ â†’ à¹„à¸¡à¹ˆà¸£à¸±à¸™ Fixscript")
	end

	return nil
end

-- ================== INCUBATOR ==================
local function getPlayerIncubator()
	local plots = workspace:WaitForChild("Interactions")
		:WaitForChild("Plots")
		:WaitForChild("Plots")

	local plot = plots:FindFirstChild(LocalPlayer.Name .. "_Plot")
	if not plot then return end

	local base = plot:FindFirstChild("Base")
	local buildings = base and base:FindFirstChild("Buildings")
	return buildings and buildings:FindFirstChild("Incubator")
end

-- ================== TUTORIAL FUNCTIONS ==================
local function completeEggTutorial()
	safeFire(Remotes.PostTutorialStageRemote, "InteractWithEgg")
	safeInvoke(Remotes.ReplicateItemRemote, {Name="Tutorial",Category="Eggs"}, "Model")
	safeFire(Remotes.PostTutorialStageRemote, "CompleteEggNestInteraction")
	safeInvoke(Remotes.SetTutorialStageRemote, "HatchingEggs")
end

local function completeIncubatorTutorial()
	local incubator = getPlayerIncubator()
	if not incubator then return end

	safeFire(Remotes.PostTutorialStageRemote, "InteractWithIncubator")
	safeInvoke(incubator.IncubateRemote, "Tutorial")
	safeFire(Remotes.PostTutorialStageRemote, "PlaceEggInIncubator")
	safeInvoke(incubator.ClaimRemote)
	safeFire(Remotes.PostTutorialStageRemote, "ClaimEgg")
	safeInvoke(Remotes.SetTutorialStageRemote, "GrowingDragon")
end

local function completeGrowDragonTutorial()
	safeFire(Remotes.PostTutorialStageRemote, "OpenInteractMenuWithDragon")
	safeInvoke(Remotes.GrowDragonRemote, "1")
	safeFire(Remotes.PostTutorialStageRemote, "GrowDragon")
	safeFire(Remotes.PostTutorialStageRemote, "RideDragon")
	safeInvoke(Remotes.SetTutorialStageRemote, "SkillsIntroduction")
	safeInvoke(Remotes.EquipDragonRemote, "1")
end

local function completeFlyingTutorialStage()
	local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
	local dragons = char:WaitForChild("Dragons", 5)
	if not dragons then return end

	local dragon = dragons:FindFirstChild("1")
	if not dragon then return end

	safeFire(dragon.Remotes.FlyingRemote, true)
	safeFire(Remotes.PostTutorialStageRemote, "FlyDragon")

	for i = 1,3 do
		safeFire(Remotes.RidingRingTouchedRemote, "Tutorial")
		safeFire(Remotes.PostTutorialStageRemote, "FlyThroughRing"..i)
	end

	safeFire(Remotes.PostTutorialStageRemote, "GotCloseToTarget")
	safeFire(Remotes.PostTutorialStageRemote, "StartedFireBreath")
	safeFire(Remotes.PostTutorialStageRemote, "DestroyTarget1")
	safeFire(Remotes.PostTutorialStageRemote, "DestroyTarget2")
	safeFire(Remotes.PostTutorialStageRemote, "DestroyTarget3")

	safeFire(Remotes.PoppedDiscoverIndicatorRemote, "EggNest", "Tutorial")
	safeFire(Remotes.PostTutorialStageRemote, "InteractWithEgg2")
	safeFire(Remotes.PostTutorialStageRemote, "CompleteEggNestInteraction2")
	safeInvoke(Remotes.SetTutorialStageRemote, "NextWorld")
end

local function completeSecondIncubatorTutorial()
	local incubator = getPlayerIncubator()
	if not incubator then return end

	safeFire(Remotes.PostTutorialStageRemote, "InteractWithIncubator2")
	safeInvoke(incubator.IncubateRemote, "TutorialCompleteEgg")
	safeFire(Remotes.PostTutorialStageRemote, "PlaceEggInIncubator2")
	safeInvoke(incubator.ClaimRemote)
	safeFire(Remotes.PostTutorialStageRemote, "ClaimEgg2")
	safeInvoke(Remotes.SetTutorialStageRemote, "Complete")
end

-- ================== START FLOW ==================
print("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
print("ğŸš€ à¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™à¸£à¸°à¸šà¸š Tutorial Complete")
print("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")

-- ğŸ‰ à¹€à¸£à¸´à¹ˆà¸¡à¸£à¸°à¸šà¸šà¸¡à¸±à¸‡à¸à¸£
setupDragonSystem()

-- âŒ¨ï¸ à¹€à¸£à¸´à¹ˆà¸¡à¸£à¸°à¸šà¸šà¸à¸” Q
setupAutoFlyControl()

print("â³ à¸£à¸­à¸£à¸°à¸šà¸šà¹‚à¸«à¸¥à¸” 3 à¸§à¸´...")
task.wait(3)

-- à¹€à¸£à¸´à¹ˆà¸¡ Tutorial Flow
local nest = waitForNestOrFix(5)

if not nest then
	warn("â›” à¹„à¸¡à¹ˆà¸à¸š Nest à¹à¸¡à¹‰à¸«à¸¥à¸±à¸‡à¸—à¸³à¹€à¸„à¸§à¸ª Lobby à¹à¸¥à¸°à¸£à¸±à¸™ Fixscript")
	warn("ğŸ”„ à¸à¸£à¸¸à¸“à¸²à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¹à¸¥à¸°à¸£à¸µà¸ˆà¸­à¸¢à¸™à¹Œ")
	_G.TUTORIAL_SCRIPT_RUNNING = false
	return
end

print("âœ… à¸à¸š Nest â†’ à¹€à¸£à¸´à¹ˆà¸¡à¸—à¸³ Tutorial")

for i = 1, 5 do
	print("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
	print("ğŸ” à¸£à¸­à¸šà¸—à¸µà¹ˆ", i)
	print("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
	
	completeEggTutorial()
	task.wait(0.1)
	completeIncubatorTutorial()
	task.wait(0.1)
	completeGrowDragonTutorial()
	task.wait(0.1)
	completeFlyingTutorialStage()
	task.wait(0.1)
	completeSecondIncubatorTutorial()
	task.wait(0.1)
end

print("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
print("âœ… Tutorial à¹€à¸ªà¸£à¹‡à¸ˆà¸ªà¸¡à¸šà¸¹à¸£à¸“à¹Œ!")
print("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")

-- à¸§à¸²à¸£à¹Œà¸›à¸à¸¥à¸±à¸š Lobby
print("ğŸŒ à¸§à¸²à¸£à¹Œà¸›à¹„à¸› Lobby...")
task.wait(3)
safeInvoke(Remotes.WorldTeleportRemote, 3475397644, {})

-- à¸›à¸´à¸”à¸£à¸°à¸šà¸š
task.wait(5)
_G.TUTORIAL_SCRIPT_RUNNING = false
print("ğŸ›‘ à¸£à¸°à¸šà¸šà¸«à¸¢à¸¸à¸”à¸—à¸³à¸‡à¸²à¸™")
